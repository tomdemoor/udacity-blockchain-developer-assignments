// Generated by psc version 0.9.3
"use strict";
var $foreign = require("./foreign");
var Prelude = require("../Prelude");
var Data_Maybe = require("../Data.Maybe");
var Data_Eq = require("../Data.Eq");
var Data_Ord = require("../Data.Ord");
var Data_Ordering = require("../Data.Ordering");
var Data_Show = require("../Data.Show");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Semiring = require("../Data.Semiring");
var Data_Ring = require("../Data.Ring");
var Data_CommutativeRing = require("../Data.CommutativeRing");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var showBigInt = new Data_Show.Show(function (x) {
    return "fromString \"" + ($foreign.toString(x) + "\"");
});
var semiringBigInt = new Data_Semiring.Semiring($foreign.biAdd, $foreign.biMul, $foreign.fromInt(1), $foreign.fromInt(0));
var ringBigInt = new Data_Ring.Ring(function () {
    return semiringBigInt;
}, $foreign.biSub);
var fromBase = $foreign["fromBase'"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
var fromString = fromBase(10);
var eqBigInt = new Data_Eq.Eq($foreign.biEquals);
var ordBigInt = new Data_Ord.Ord(function () {
    return eqBigInt;
}, function (x) {
    return function (y) {
        var $0 = $foreign.biCompare(x)(y);
        if ($0 === 1) {
            return Data_Ordering.GT.value;
        };
        if ($0 === 0) {
            return Data_Ordering.EQ.value;
        };
        return Data_Ordering.LT.value;
    };
});
var commutativeRingBigInt = new Data_CommutativeRing.CommutativeRing(function () {
    return ringBigInt;
});
var euclideanRingBigInt = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingBigInt;
}, function ($1) {
    return Data_EuclideanRing.degree(Data_EuclideanRing.euclideanRingNumber)($foreign.toNumber($1));
}, $foreign.biDiv, $foreign.biMod);
module.exports = {
    fromBase: fromBase, 
    fromString: fromString, 
    eqBigInt: eqBigInt, 
    ordBigInt: ordBigInt, 
    showBigInt: showBigInt, 
    semiringBigInt: semiringBigInt, 
    ringBigInt: ringBigInt, 
    commutativeRingBigInt: commutativeRingBigInt, 
    euclideanRingBigInt: euclideanRingBigInt, 
    abs: $foreign.abs, 
    even: $foreign.even, 
    fromInt: $foreign.fromInt, 
    modPow: $foreign.modPow, 
    negative: $foreign.negative, 
    odd: $foreign.odd, 
    positive: $foreign.positive, 
    pow: $foreign.pow, 
    prime: $foreign.prime, 
    toBase: $foreign.toBase, 
    toNumber: $foreign.toNumber, 
    toString: $foreign.toString
};
