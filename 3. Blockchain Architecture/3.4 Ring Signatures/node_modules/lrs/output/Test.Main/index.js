// Generated by psc version 0.9.3
"use strict";
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Console = require("../Control.Monad.Eff.Console");
var Crypto_LRS_SimpleAPI = require("../Crypto.LRS.SimpleAPI");
var Data_Array = require("../Data.Array");
var Data_BigInt = require("../Data.BigInt");
var Data_BigInt_Random = require("../Data.BigInt.Random");
var Data_Maybe = require("../Data.Maybe");
var Data_String = require("../Data.String");
var Data_Unfoldable = require("../Data.Unfoldable");
var Prelude = require("../Prelude");
var Test_Assert = require("../Test.Assert");
var Crypto_LRS = require("../Crypto.LRS");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Functor = require("../Data.Functor");
var Control_Bind = require("../Control.Bind");
var Data_Traversable = require("../Data.Traversable");
var Data_Function = require("../Data.Function");
var Data_Show = require("../Data.Show");
var Data_Ring = require("../Data.Ring");
var Control_Category = require("../Control.Category");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra");
var formatSignature = function (v) {
    return Data_BigInt.toBase(16)(v.value0) + ("|" + (Data_BigInt.toBase(16)(v.value1) + ("|" + Data_String.joinWith(":")(Data_Functor.map(Data_Functor.functorArray)(Data_BigInt.toBase(16))(v.value2)))));
};
var formatParty = function (v) {
    return Data_BigInt.toBase(16)(v.value0) + ("/" + Data_BigInt.toBase(16)(v.value1));
};
var main = function __do() {
    Control_Monad_Eff_Console.log("\n:: Generating ring with 16 members...")();
    var v = Data_Unfoldable.replicateA(Control_Monad_Eff.applicativeEff)(Data_Unfoldable.unfoldableArray)(Data_Traversable.traversableArray)(16)(Crypto_LRS_SimpleAPI.gen)();
    var pvts = Data_Functor.map(Data_Functor.functorArray)(Crypto_LRS.privateKey)(v);
    var pubs = Data_Functor.map(Data_Functor.functorArray)(Crypto_LRS.publicKey)(v);
    var party = function (n) {
        return Data_Maybe.fromMaybe(new Crypto_LRS.Party(Data_BigInt.fromInt(0), Data_BigInt.fromInt(0)))(Data_Array.index(v)(n));
    };
    Data_Function.apply(Control_Monad_Eff_Console.log)("\n:: Generated PUB/PVT key pairs: ")();
    Data_Function.apply(Control_Monad_Eff_Console.log)(Data_Function.apply(Data_String.joinWith("\n"))(Data_Functor.map(Data_Functor.functorArray)(function (i) {
        return "MEMBER " + (Data_Show.show(Data_Show.showInt)(i) + (": " + formatParty(party(i))));
    })(Data_Array.range(0)(Data_Array.length(v) - 1))))();
    Control_Monad_Eff_Console.log("\n:: Generating test signatures...")();
    var v1 = Crypto_LRS_SimpleAPI.sign(pubs)(party(0))("testMsg0")();
    var v2 = Crypto_LRS_SimpleAPI.sign(pubs)(party(1))("testMsg1")();
    var v3 = Crypto_LRS_SimpleAPI.sign(pubs)(party(2))("testMsg2")();
    var v4 = Crypto_LRS_SimpleAPI.sign(pubs)(party(0))("testMsg3")();
    Control_Monad_Eff_Console.log("\n:: Generated signatures:")();
    Data_Function.apply(Control_Monad_Eff_Console.log)("MSG: 'testMsg0' (from member 0/16); SIG: " + formatSignature(v1))();
    Data_Function.apply(Control_Monad_Eff_Console.log)("MSG: 'testMsg1' (from member 1/16); SIG: " + formatSignature(v2))();
    Data_Function.apply(Control_Monad_Eff_Console.log)("MSG: 'testMsg2' (from member 2/16); SIG: " + formatSignature(v3))();
    Data_Function.apply(Control_Monad_Eff_Console.log)("MSG: 'testMsg3' (from member 0/16); SIG: " + formatSignature(v4))();
    var testSig = function (conf) {
        return function (sig) {
            return function (i) {
                return function (msg) {
                    var fn = (function () {
                        if (conf) {
                            return Control_Category.id(Control_Category.categoryFn);
                        };
                        if (!conf) {
                            return Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
                        };
                        throw new Error("Failed pattern match at Test.Main line 52, column 20 - line 52, column 44: " + [ conf.constructor.name ]);
                    })();
                    var verb = (function () {
                        if (conf) {
                            return "proves";
                        };
                        if (!conf) {
                            return "doesn't prove";
                        };
                        throw new Error("Failed pattern match at Test.Main line 53, column 20 - line 54, column 9: " + [ conf.constructor.name ]);
                    })();
                    return function __do() {
                        Data_Function.apply(Test_Assert.assert)(fn(Crypto_LRS_SimpleAPI.verify(pubs)(sig)(msg)))();
                        return Control_Monad_Eff_Console.log("signature " + (Data_Show.show(Data_Show.showInt)(i) + (" " + (verb + (" someone signed '" + (msg + "'"))))))();
                    };
                };
            };
        };
    };
    Control_Monad_Eff_Console.log("\n:: Testing if signatures verify their messages.")();
    testSig(true)(v1)(0)("testMsg0")();
    testSig(true)(v2)(1)("testMsg1")();
    testSig(true)(v3)(2)("testMsg2")();
    testSig(true)(v4)(3)("testMsg3")();
    Control_Monad_Eff_Console.log("\n:: Testing if signatures fail to verify false messages.")();
    testSig(false)(v4)(0)("arbitraryMsg")();
    testSig(false)(v4)(1)("arbitraryMsg")();
    testSig(false)(v4)(2)("arbitraryMsg")();
    testSig(false)(v4)(3)("arbitraryMsg")();
    Control_Monad_Eff_Console.log("\n:: Testing if signatures fail to verify another signature's messages.")();
    testSig(false)(v1)(0)("testMsg1")();
    testSig(false)(v1)(0)("testMsg2")();
    testSig(false)(v1)(0)("testMsg3")();
    testSig(false)(v2)(1)("testMsg0")();
    testSig(false)(v2)(1)("testMsg2")();
    testSig(false)(v2)(1)("testMsg3")();
    testSig(false)(v3)(2)("testMsg0")();
    testSig(false)(v3)(2)("testMsg1")();
    testSig(false)(v3)(2)("testMsg3")();
    testSig(false)(v4)(3)("testMsg0")();
    testSig(false)(v4)(3)("testMsg1")();
    testSig(false)(v4)(3)("testMsg2")();
    Control_Monad_Eff_Console.log("\n:: Testing if signatures fail to verify their messages, but with different rings.")();
    var subpubs = Data_Maybe.fromMaybe([  ])(Data_Array.tail(pubs));
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.verify(subpubs)(v1)("testMsg0"))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.verify(subpubs)(v2)("testMsg1"))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.verify(subpubs)(v3)("testMsg2"))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.verify(subpubs)(v4)("testMsg3"))();
    Control_Monad_Eff_Console.log("all signatures failed to verify their messages for different rings")();
    Control_Monad_Eff_Console.log("\n:: Testing if the linked signature is accused.")();
    Data_Function.apply(Test_Assert.assert)(Crypto_LRS_SimpleAPI.link(v1)(v4))();
    Control_Monad_Eff_Console.log("signatures 0 and 3 were signed by the same person")();
    Control_Monad_Eff_Console.log("\n::Testing if unlinked signatures aren't accused.")();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.link(v1)(v2))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.link(v1)(v3))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.link(v2)(v3))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.link(v2)(v4))();
    Data_Function.apply(Test_Assert.assert)(!Crypto_LRS_SimpleAPI.link(v3)(v4))();
    Control_Monad_Eff_Console.log("no other pair of signatures was signed by the same person")();
    return Control_Monad_Eff_Console.log("")();
};
module.exports = {
    formatParty: formatParty, 
    formatSignature: formatSignature, 
    main: main
};
